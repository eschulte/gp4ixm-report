#+TITLE: Genetic Programming on IXM
#+OPTIONS: num:nil ^:nil
#+LaTeX_CLASS: normal
#+STARTUP: hideblocks

* Report
** Introduction
A system of subpopulation Genetic Programming (GP) is implemented over
Illuminato X Machina (IXM)[fn:1] boards.  The GP system is designed in
the spirit of the IXM boards and attempts to explore the
intuitions[fn:2] which served as the impetus for the board's creation.
A series of experiments assess the effects of varying traditional GP
parameters, of applying coevolution and of various physical layouts on
the relative success of the GP.  The inherently redundant and
distributed nature of subpopulation GP is shown to be a natural fit
for the IXM environment and directions for future work are discussed.
In the spirit of Reproducible Research[fn:3], all source code and
experimental data referenced in this work is made available to the
reader (see [[reproduction]]) in the hopes of encouraging further work in
this area.

** Illuminato X Machina -- telos and construction
An IXM[fn:1] board is a small square board containing an atom
processor, memory, a button, led lights, hardware timers, a power rail
and four connectors arrayed around the perimeter of the board.
Although each board is in essence a small self-contained computer they
are intended to be used in groups.  When multiple boards are connected
through they communicate and share power with their neighbors through
their side connections.

#+Caption: 37 IXM boards in operation
[[file:data/big-grid.png]]

One goal of the boards was to enable experimentation with software
developed under a new set of assumptions.  On a grid of IXM boards the
central single CPU, the shared memory and the global clock of a
traditional computer are relinquished in favor of a dynamic set of
loosely coupled peers, each equipped with it's own personal clock
processor and memory.  In such an environment robustness of operation
is achieved through the abandonment of privileged points in space and
time and the duplication of functionality across a largely homogeneous
populations of peers.

This work attempts to manifest these themes in a GP implementation
which will run effectively in the IXM environment.

** GP -- implementation and defense of deviations from the norm
In an effort to better align with the IXM platform the GP system
employed in this work differs from GP norms in a number of areas.
These deviations will be defended as they arise.

First an overview of the key components.

*** Representation and Fitness
This approach evolves individuals which are represented as variable
length strings of integers and arithmetic operators in Reverse Polish
Notation (RPN).  The individuals are evaluated by their ability to
match a "target" string also represented in RPN.  The simplicity of
the RPN stack machine facilitated quick development on the IXM boards.

#+Caption: RPN stack machine
[[file:data/rpn-stack.png]]

#+begin_src ditaa :file data/rpn-stack.png :exports none :results silent
    RPN                 operands   (grow stack)
                     +-----------------------------+
                 ^   |  0 1 2 3 4 5 6 7 8 9        |
  +------+       |   |                             |
  |      |           +-----------------------------+
  |      |                                    
  |      |              operators  (shrink stack)
  |  56  |           +-----------------------------+
  |  34  |       |   | + - x %                     |
  |  8   |       v   |                             |
  |  9   |           +-----------------------------+
  +------+
   stack 
#+end_src

The only difference between the individual strings and the possible
goal strings is the inclusion of the 'sine' operator in the goal
strings.  This unbalance encourages interesting behavior of the
evolving individuals as they tackle the difficult task of
approximating a trigonometric function using arithmetic operators --
in effect evolving towards a Taylor Series.

*** Genetic Operators
New individuals are generated in the following three manners.  In each
of the following when an individual is needed as an input to the
operation that individual is selected from the population through
using tournament selection.
- injection :: A new individual is created from whole cloth.  Each
     element in the individual's RPN string is selected at random from
     the set of all valid RPN characters.  This is the process used to
     generated an initial population immediately after board boot-up.
     #+begin_src c++ :exports code
       char possibilities[16] = BUILDING_BLOCKS;
       ind.representation[0] = possibilities[random(15)];
       for(int i=0; i < random(IND_SIZE); ++i) {
         ind.representation[i] = possibilities[random(15)];
         index = i;
       }
     #+end_src
- mutation :: An modified copy is made of an existing individual.
     First an exact copy is made, then each step of the copies RPN
     string is mutated with a probability equal to $1/mutation\_prob$
     where $mutation\_prob$ is a parameter of the GP system.
     #+begin_src c++ :exports code
       char possibilities[16] = BUILDING_BLOCKS;
       for(int i=0; i<size(); ++i)
         if(random(size()) == mutation_prob)
           representation[i] = possibilities[random(15)];
     #+end_src
- crossover :: Single point crossover is used to combine to existing
     individuals to generate a new individual.  First a crossover
     point is picked for each parent, then the first half from one
     parent is combined with the second half from the other parent as
     shown.
     #+begin_src c++ :exports code
       int mother_point = random(mother->size());
       int father_point = random(father->size());
       for(int i=0; i<mother_point; ++i) {
         child.representation[index] = mother->representation[i];
         ++index;
       }
       for(int i=father_point; i<father->size(); ++i) {
         if((index+1) >= (IND_SIZE - 1)) break;
         child.representation[index] = father->representation[i];
         ++index;
       }
       child.representation[index] = '\0';
     #+end_src
- sharing :: During sharing an individual is selected and is "shared"
     with all of the IXM board's neighbors.

*** Population Operations -- avoiding privileged points
Up to this point the GP system we have introduced is largely standard
and should be unsurprising.  Where our system differs from traditional
GP is in the timing and distribution of operations on the population
of individuals.  Since one of our goals is uniformity in both space
and time we discard the notion of a fixed population cycle and instead
perform all GP operations at constant frequencies.  As such there are
no discrete "stages" or "steps" in our GP.

Using hardware timers included on the IXM boards we scheduler the
operations of mutation, injection, crossover, and sharing to recur at
fixed frequencies.  The frequency of these operations are parameters
of the GP system.  Whenever one of these operations returns a new
individual (e.g. the product of crossover, or an individual shared by
a neighbor board) the new individual is incorporated into the
population and the current worst individual is removed form the
population.  The only time an individual will be removed from the
population is when it is displaced in this manner.

Given the above setup all of the GP operations are constantly acting
on the population in a semi-stochastic interleaved manner.  No
randomness is explicitly added to the operation scheduling (although
this would be sympathetic with our themes) however as the boards
periodically become too busy pending GP operations are can be delayed
adding an element of randomness to the system.

*** Board Layout
The following illustrates the functional components of our GP
framework as implemented out on a single board.

#+Caption: Layout of a single IXM board
[[file:data/board-layout.png]]

#+begin_src ditaa :file data/board-layout.png :cmdline -r :exports none :results silent
                                          Outside (neighbors)
  +-----------------------------------------------------------------------------------------+
  |                                        Inside (on board)                                |
  |        +----------------------+                                                         |
  |        |  Crossover           |                                                         |
  |        |                      |                                                         |
  |        |  takes pairs of      |                    share                                |
  |        |  individuals and     |   /-------------------------------------------------------->
  |        |  combines them to    |   |                                                     |
  |        |  produce ind.        |<--*-----------------------------\  Select               |
  |        |cBDB                  |   |                             |                       |
  |        +----------------------+   |                             |  takes "good" ind's   |
  |                   |               |                             |  from the population  |
  |                   v               |                             | (tournament selection)|
  |     +-------------------+         |                             |                       |
  |     |  Incorporate      |         |            +-----------------------------------+    |
  |     |                   |         |            |  Population                       |    |
  |     |  adds a new ind.  |         |            |                                   |    |
  |     |  to the pop, and  |                      |  o collection of individuals      |    |
  |     |  culls the ind.   |     new individual   |  o each has a fitness value       |    |
  |     |  with the worst   | -------------------->|  o can return the fittest         |    |
  |     |  fitness          |                      |                                   |    |
  |     |                   |         |    cull    |                                   |    |
  |     |cBDB               |         |  *<--------|                                   |    |
  |     +-------------------+         |            |                                   |    |
  |              ^        ^           |            |cBDB                               |    |
  |              |        |           |            +-----------------------------------+    |
  |  incoming    |        |           v                                ^                    |
  |  individuals |      +------------------------+                     |                    |
  |              |      | Mutate                 |                     |                    |
  |              |      |                        |                     |                    |
  |              |      |  randomly change the   |            +------------------------+    |
  |              |      |  representation of an  |            | New Individual         |    |
  |              |      |  ind. each spot w/prob |            |                        |    |
  |              |      |        1/length        |            | random new individual  |    |
  |              |      |                        |            |       (on startup)     |    |
  |              |      |cBDB                    |            |cBDB                    |    |
  |              |      +------------------------+            +------------------------+    |
  |              |                                                                          |
  +-----=--------|---------=----------------------------------------------------------------+
                 |
#+end_src

*** Properties
The GP system as described has the following properties which are
desirable for the IXM environment.
- all boards are peers
- any number of boards can be used effectively -- including a single
  board
- increasing the number of boards increases the effectiveness of the
  GP system -- following some asymptotic curve
- boards can be added to the GP system during execution and
  incorporated /on the fly/
- the system degrades gracefully as boards are removed from the system

** Results
** Future Work
- meta-GP
- taking and giving boards
- splitting up the fitness space across the boards

** Reproduction/Expansion of this work
   :PROPERTIES:
   :CUSTOM_ID: reproduction
   :END:

* Data Analysis
** basic GP parameters
just to show that mutation and crossover actually help, and to justify
the choices used in later experiments

** GP visualization
evo-individuals and coevo-individuals

connect the gnuplot graphics to the text files of results

1) ingest text files
2) persist in serialized ruby structures
3) connect to group/board data structures
4) produce graphs

** plot fitness by time
many data points, maybe a best-fit line w/R

** comparisons
*** sharing rates
**** evo-eight
***** Goal 0
- runtime -- all completed inside of 10 seconds
  #+begin_example
    irb(main):176:0> ave_max_time
    ave_max_time
    {10000=>3.6102906, 100=>6.4068757, 1000=>2.8806907}
  #+end_example
- score -- average best score, I believe this is misleading however as
  some of the 0s were not recorded for being received too early
  #+begin_example
    irb(main):185:0> ave_best_score
    ave_best_score
    {10000=>3192.3, 100=>0.0, 1000=>3157.8}
  #+end_example
- percent fully completed -- again I believe these should all be 10/10
  but are different due to recording errors.  Strong evidence in favor
  of this is the fact that recording terminated which only occurs
  after receiving a fully successful individual.
  - s = 100 completed 10/10
  - s = 1000 completed 8/10
  - s = 10000 completed 8/10

***** Goal 1
- runtime -- all completed inside of 10 minutes
  #+begin_example 
    irb(main):204:0> ave_max_time
    ave_max_time
    {10000=>24.0118271, 100=>1.9693912, 1000=>3.1030883}
  #+end_example
- score -- all run completed so all reached best possible score
  #+begin_example 
    irb(main):212:0> ave_best_score
    ave_best_score
    {10000=>0.0, 100=>0.0, 1000=>0.0}
  #+end_example
- example individual =4827-*/*/7xxx**+=
  
***** Goal 2
- runtime -- no runs completed
  #+begin_example
    irb(main):052:0> ave_max_time
    ave_max_time
    {10000=>1207.943955, 100=>1207.720609, 1000=>1210.959188}
  #+end_example
- score -- looks like two actually succeeded...
  #+begin_example
    irb(main):096:0> ave_best_score
    ave_best_score
    {10000=>255.311111111111, 100=>253.433333333333, 1000=>183.966666666667}
  #+end_example
- best individual at 100 sharing with
  - score -- 1206.406949
  - rep -- =((((7 * (5 * ((((7 / x) - 3) + x) / (3 - x)))) / x) + x) * x)=
  - graph -- [[file:graphs/s_100_g_2_best.png]]

**** evo-line
***** Goal 0


***** Goal 1
***** Goal 2

**** coevo-eight
***** Goal 0
- run-time -- looks like most aren't finishing
  #+begin_example 
    irb(main):298:0> ave_max_time
    ave_max_time
    {10000=>1207.0363047, 100000=>1206.9868935, 1000=>1207.0620207}
  #+end_example
- score -- average best seems to indicate faster sharing is better
  #+begin_example
    irb(main):322:0> ave_best_score
    ave_best_score
    {10000=>16.624, 100000=>89985.059, 1000=>5986.421}
  #+end_example
- success rate -- looks like some *did* succeed
  #+begin_example
    irb(main):339:0> best_scores[1000]
    best_scores[1000]
    [1.0, 1.0, 7.0, 9.0, 0.0, 0.0, 7.0, 6.0, 59826.21, 7.0]
  #+end_example

- individual

*** line vs. eight
*** evo vs. coevo
** tools
*** ingest a directory of results into ruby
ingest a directories worth of run results and return a list of Datum
#+source: ingest
#+begin_src ruby
  class Datum
    attr_accessor :share, :goal, :run, :time, :score, :path
  end
  def ingest(base)
    Dir.entries(base).map do |e|
      if (e.match(/r_s.(\d+)_m.(\d+)_b.(\d+)_i.(\d+)_g.(\d+).(\d+)/) or
          e.match(/r_S.(\d+)_s.\d+_m.(\d+)_b.(\d+)_i.(\d+)_g.(\d+).(\d+)/))
        share = Integer($1)
        goal  = Integer($5)
        run   = Integer($6)
        File.read(File.join(base, e)).map do |l|
          if l.match(/^([\d\.\/-]+)\t([\d\.\/-]+)\t([frl]+)$/)
            d = Datum.new
            d.share = share
            d.goal  = goal
            d.run   = run
            d.time  = Float($1) rescue -1
            d.score = Float($2) rescue -1
            d.path  = $3
            d
          end
        end.compact
      end
    end.compact.flatten
  end
#+end_src

test ingest -- works -- 512783 data points in the directory
#+begin_src ruby :noweb :results output silent :tangle feed :session
  <<ingest>>
  data = ingest("./raw/15-evo-line/");''
  puts data.size
#+end_src

**** serialize -- not plausible
tried YAML and sqlite3 and neither worked in a reasonable amount of
time

creating a sqlite3 table to hold this info
#+begin_src ruby
  # create database
  db = SQLite3::Database.new('raw.db')
  
  table = "evo_eight"
  
  # create table
  db.execute("create table #{table} (share INT, goal INT, run INT, time FLOAT, score FLOAT, path STRING);")
  
  # define keys
  keys = %w{share goal run time score path}
  
  # create a large insert statement for 1000 data points
  stmt = data.map{ |d| "insert into #{table} (#{keys.join(", ")}) values (#{keys[0..-2].map{|k| d.send(k.intern) }.join(", ")}, '#{d.path}');" }
  
  db.transaction{ |db| db.execute_batch(stmt.join("\n")) }
#+end_src

*** rpn to alg

evo individuals are check on the (0..9) range inclusive

#+results: rpn-string
| 0757x/3-x+3x-/**x/x+x* |

#+source: rpn-to-alg
#+begin_src ruby :var ind=rpn-string :results output
  operators = %W{+ - / *}
  $stack = []
  ind[0][0].split(//).each do |ch|
    if operators.include?(ch)
      right = $stack.pop or "1"
      left = $stack.pop or "1"
      $stack.push("(#{left} #{ch} #{right})")
    else
      $stack.push(ch)
    end
  end
  puts $stack.pop
#+end_src

#+begin_src gnuplot
  set xrange[0:10]
  set xtics 0,1,10
  set yrange[-120:120]
  set grid
  plot 100 * sin(x), ((((7 * (5 * ((((7 / x) - 3) + x) / (3 - x)))) / x) + x) * x)
#+end_src

wider range

#+begin_src gnuplot
  set grid
  plot 100 * sin(x), ((((7 * (5 * ((((7 / x) - 3) + x) / (3 - x)))) / x) + x) * x)
#+end_src


*** narrow down to a specific goal
#+begin_src ruby
  by_goal = data.select{|d| d.goal == 0}; by_goal.size
#+end_src

*** clear out early individuals
need to clear out individuals from previous runs -- namely those
returned before the reset packet
#+begin_src ruby
  # make sure to remove individuals from before reset packet
  temp_by_goal = by_goal.reject{|d| d.time < 2};
#+end_src

*** ave_max_runtimes
#+source: ave_max_runtimes
#+begin_src ruby
  ave_max_time = {}
  [1000, 10000, 100000].each do |share|
    data_s = temp_by_goal.select{|d| d.share == share}
    ave_max_time[share] = (0..9).map{|r| data_s.select{|d| d.run == r }.
      sort_by{|d| d.time}.last.time}.inject(0){|a,t| a += t} / 10
  end
#+end_src

*** ave_best_score -- for evo
#+source: ave_best_score
#+begin_src ruby
  ave_best_score = {}
  [100, 1000, 10000].each do |share|
    data_s = temp_by_goal.select{|d| d.share == share}
    ave_best_score[share] = (0..9).map{|r| data_s.select{|d| d.run == r }.
      sort_by{|d| d.score}.first.score}.inject(0){|a,t| a += t} / 10
  end
#+end_src

*** ave_best_score -- for coevo
 be careful about negative scores
#+source: ave_best_score
#+begin_src ruby
  ave_best_score = {}
  [1000, 10000, 100000].each do |share|
    data_s = temp_by_goal.select{|d| d.share == share}
    ave_best_score[share] = (0..9).map{|r| data_s.select{|d| d.run == r }.
      select{|d| d.score >= 0}.
      sort_by{|d| d.score}.first.score}.inject(0){|a,t| a += t} / 10
  end
#+end_src

*** best_inds
#+source: best_inds
#+begin_src ruby
  best_inds = {}
  [100, 1000, 10000].each do |share|
    data_s = temp_by_goal.select{|d| d.share == share}
    best_inds[share] = (0..9).map{|run| data_s.sort_by{|d| d.score}.first}.
      sort_by{|d| d.score}.first
  end
#+end_src

*** graph of the fitness of a run
#+begin_src ruby :session
  file.open('/tmp/goal_0_coevo.txt', 'w'){|f| f << by_goal.select{|d| d.share == 1000}.select{|d| d.run == 4}.sort_by{|d| d.time}.map{|d| "#{d.time}\t#{d.score}" }.join("\n") }
#+end_src

#+begin_src gnuplot
  plot '/tmp/goal_0_coevo.txt' using 1:2
#+end_src

*** visualize
visualize -- dump a set of data to a series of png images in a directory
#+begin_src ruby
  require 'src/group.rb'
  def visualize(data, share, goal, run)
    path = File.join(Dir.pwd, "./videos/#{share}_#{goal}_#{run}/")
  
    # initialize the group
    g = Group.new(path)
  
    # pare down the data
    my_data = data.select{|d| (d.run == run) && (d.goal == goal) && (d.share == share)}
    
    # make the graphs
    timer = 0
    my_data.sort_by{|d| d.time}.each do |d|
      g.update("c#{d.score} #{d.path}")
      # if d.time.floor > timer
      #   timer = d.time.floor
      #   g.plot(timer)
      # end
      if d.time < 20
        timer += 1
        g.plot(sprintf("%04d", timer))
      end
    end
    timer
  end
#+end_src

#+begin_src ruby
  visualize(temp_by_group, 1000, 0, 4)
#+end_src

conversion into a movie
- with instructions from http://electron.mit.edu/~gsteele/ffmpeg/
- done with ffmpeg
  #+begin_src sh
    ffmpeg -r 4 -i %04d.png ./evo_eight_100_2_1.mp4
  #+end_src

* Footnotes

[fn:1] http://illuminatolabs.com/IlluminatoHome.htm

[fn:2] http://reproducibleresearch.net/index.php/Main_Page

[fn:3] http://livingcomputation.com/rpc/

