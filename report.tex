% Created 2009-12-15 Tue 21:36
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{soul}
\usepackage{hyperref}
\usepackage{color}
\usepackage{tikz}
\usepackage{listings}
\usepackage{movie15}

\title{Genetic Programming on IXM}
\author{Eric}
\date{15 December 2009}

\begin{document}

\maketitle


\section*{Report}
\label{sec-1}

\subsection*{Introduction}
\label{sec-1.1}

A system of subpopulation Genetic Programming (GP) is implemented over
Illuminato X Machina (IXM)\footnote{\href{http://illuminatolabs.com/IlluminatoHome.htm}{http://illuminatolabs.com/IlluminatoHome.htm} } boards.  The GP system is designed in
the spirit of the IXM boards and attempts to explore the
intuitions\footnote{\href{http://reproducibleresearch.net/index.php/Main_Page}{http://reproducibleresearch.net/index.php/Main\_Page} } which served as the impetus for the board's creation.
A series of experiments assess the effects of varying traditional GP
parameters, of applying coevolution and of various physical layouts on
the relative success of the GP.  The inherently redundant and
distributed nature of subpopulation GP is shown to be a natural fit
for the IXM environment and directions for future work are discussed.
In the spirit of Reproducible Research\footnote{\href{http://livingcomputation.com/rpc/}{http://livingcomputation.com/rpc/} }, all source code and
experimental data referenced in this work is made available to the
reader (see \hyperref[sec-1.7]{reproduction}) in the hopes of encouraging further work in
this area.

\subsection*{Illuminato X Machina -- telos and construction}
\label{sec-1.2}

An IXM$^{1}$ board is a small square board containing an atom
processor, memory, a button, led lights, hardware timers, a power rail
and four connectors arrayed around the perimeter of the board.
Although each board is in essence a small self-contained computer they
are intended to be used in groups.  When multiple boards are connected
through they communicate and share power with their neighbors through
their side connections.

\begin{figure}[htb]
\centering
\includegraphics[width=10em]{data/big-grid.png}
\caption{37 IXM boards in operation}
\end{figure}

One goal of the boards is to enable experimentation with software
developed under a new set of assumptions.  On a grid of IXM boards the
central single CPU, the shared memory and the global clock of a
traditional computer are relinquished in favor of a dynamic set of
loosely coupled peers, each equipped with it's own personal clock
processor and memory.  In such an environment robustness of operation
is achieved through the abandonment of privileged points in space and
time and the duplication of functionality across a largely homogeneous
populations of peers.

This work attempts to manifest these themes in a GP implementation
which will run effectively in the IXM environment.

\subsection*{GP -- implementation and defense of deviations from the norm}
\label{sec-1.3}

In an effort to better align with the IXM platform the GP system
employed in this work differs from GP norms in a number of areas.
These deviations will be defended as they arise.  The source code for
the GP implementation described below can be found in
\href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/evolve-sketch.pde}{evolve-sketch.pde} and \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/coevolve-sketch.pde}{coevolve-sketch.pde}.  Both files use the
\href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/collector/}{collector/} IXM library for communicating results back to a central
source.

\subsubsection*{Representation and Fitness}
\label{sec-1.3.1}

This approach evolves individuals which are represented as variable
length strings of integers and arithmetic operators in Reverse Polish
Notation (RPN).  The individuals are evaluated by their ability to
match a ``target'' string also represented in RPN.  The simplicity of
the RPN stack machine facilitated quick development on the IXM boards.

\begin{figure}[htb]
\centering
\includegraphics[width=10em]{data/rpn-stack.png}
\caption{RPN stack machine}
\end{figure}



The only difference between the individual strings and the possible
goal strings is the inclusion of the `sine' operator in the goal
strings.  This unbalance encourages interesting behavior of the
evolving individuals as they tackle the difficult task of
approximating a trigonometric function using arithmetic operators --
in effect evolving towards a Taylor Series.

\subsubsection*{Genetic Operators}
\label{sec-1.3.2}

New individuals are generated in the following three manners.  In each
of the following when an individual is needed as an input to the
operation that individual is selected from the population through
using tournament selection.
\begin{description}
\item[injection] A new individual is created from whole cloth.  Each
     element in the individual's RPN string is selected at random from
     the set of all valid RPN characters.  This is the process used to
     generated an initial population immediately after board boot-up.
\lstset{language=c++}
\begin{lstlisting}
char possibilities[16] = BUILDING_BLOCKS;
ind.representation[0] = possibilities[random(15)];
for(int i=0; i < random(IND_SIZE); ++i) {
  ind.representation[i] = possibilities[random(15)];
  index = i;
}
\end{lstlisting}
\item[mutation] An modified copy is made of an existing individual.
     First an exact copy is made, then each step of the copies RPN
     string is mutated with a probability equal to $1/mutation\_prob$
     where $mutation\_prob$ is a parameter of the GP system.
\lstset{language=c++}
\begin{lstlisting}
char possibilities[16] = BUILDING_BLOCKS;
for(int i=0; i<size(); ++i)
  if(random(size()) == mutation_prob)
    representation[i] = possibilities[random(15)];
\end{lstlisting}
\item[crossover] Single point crossover is used to combine to existing
     individuals to generate a new individual.  First a crossover
     point is picked for each parent, then the first half from one
     parent is combined with the second half from the other parent as
     shown.
\lstset{language=c++}
\begin{lstlisting}
int mother_point = random(mother->size());
int father_point = random(father->size());
for(int i=0; i<mother_point; ++i) {
  child.representation[index] = mother->representation[i];
  ++index;
}
for(int i=father_point; i<father->size(); ++i) {
  if((index+1) >= (IND_SIZE - 1)) break;
  child.representation[index] = father->representation[i];
  ++index;
}
child.representation[index] = '\0';
\end{lstlisting}
\item[sharing] During sharing an individual is selected and is ``shared''
     with all of the IXM board's neighbors.
\end{description}

\subsubsection*{Population Operations -- avoiding privileged points}
\label{sec-1.3.3}

Up to this point the GP system we have introduced is largely standard
and should be unsurprising.  Where our system differs from traditional
GP is in the timing and distribution of operations on the population
of individuals.  Since one of our goals is uniformity in both space
and time we discard the notion of a fixed population cycle and instead
perform all GP operations at constant frequencies.  As such there are
no discrete ``stages'' or ``steps'' in our GP.

Using hardware timers included on the IXM boards we scheduler the
operations of mutation, injection, crossover, and sharing to recur at
fixed frequencies.  The frequency of these operations are parameters
of the GP system.  Whenever one of these operations returns a new
individual (e.g. the product of crossover, or an individual shared by
a neighbor board) the new individual is incorporated into the
population and the current worst individual is removed form the
population.  The only time an individual will be removed from the
population is when it is displaced in this manner.

Given the above setup all of the GP operations are constantly acting
on the population in a semi-stochastic interleaved manner.  No
randomness is explicitly added to the operation scheduling (although
this would be sympathetic with our themes) however as the boards
periodically become too busy pending GP operations are can be delayed
adding an element of randomness to the system.

\subsubsection*{Board Layout}
\label{sec-1.3.4}

The following illustrates the functional components of our GP
framework as implemented out on a single board.

\begin{figure}[htb]
\centering
\includegraphics[width=10em]{data/board-layout.png}
\caption{Layout of a single IXM board}
\end{figure}



\subsubsection*{Properties}
\label{sec-1.3.5}

The GP system as described has the following properties which are
desirable for the IXM environment.
\begin{itemize}
\item all boards are peers
\item any number of boards can be used effectively -- including a single
  board
\item increasing the number of boards increases the effectiveness of the
  GP system -- following some asymptotic curve
\item boards can be added to the GP system during execution and
  incorporated \emph{on the fly}
\item the system degrades gracefully as boards are removed from the system
\end{itemize}

\subsection*{Experimental Methodology}
\label{sec-1.4}

All experiments are run using the following methodology.  A laptop
side \href{http://www.ruby-lang.org/en/}{Ruby} script (either \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/experimenter.rb}{experimenter.rb} or \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/coexperimenter.rb}{coexperimenter.rb})
communicates with an attached group of IXM boards using the \href{http://github.com/mixonic/libixm}{libixm}
Ruby library and the \texttt{sfbprog} command distributed with the core IXM
software.  The Ruby scripts take a series of parameters and for each
combination they
\begin{enumerate}
\item input parameters to the boards
\item initiate board execution
\item collect and save raw data output by the boards
\item timeout overrunning experiments
\item repeat
\end{enumerate}

The experiments presented below had running times between 1 hour and
close to 30 hours.  The scripts are executed using the \href{http://www.gnu.org/software/screen/}{gnu screen}
program to allow persistent execution while the user is not logged
into the machine.

The boards report all results using the \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/collector/}{collector/} IXM library.  The
collector library allows each board in a group to report parameters
back to a central ``collector'' appending a ``path'' to the returned
results.  The path can be used to uniquely identify the board and
assign it coordinates in the 2D geometry of the board layout.

All graphs generated as part of this report used the collector output
as saved by the above Ruby scripts along with the \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/group.rb}{group.rb} and
\href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/board.rb}{board.rb} scripts.  These scripts translated the raw data into 2D
information in a form suitable for input to \href{http://www.gnuplot.info/}{gnuplot}.

\subsection*{Results}
\label{sec-1.5}

\subsubsection*{GP Parameters}
\label{sec-1.5.1}

Initial experimentation was aimed at ensuring both that our GP system
was able to solve simple tasks and that both GP operations (`mutation'
and `crossover') improved GP performance.

These results were generated running \href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/src/evolve-sketch.pde}{evolve-sketch.pde} on a single IXM
board.  Mutation and crossover frequencies of 10 milliseconds and 100
milliseconds (m.10, b.10, m.100, and b.100 respectively) were tested
resulting in the runtimes shown below.  Times shown are the average
time taken to generate an ideal individual over 5 runs.  The results
indicate that both mutation and crossover reduce the runtime required
for the GP to solve problems.  In addition it appears that crossover
is more effective against harder problems (e.g. ``xxx**xxxx***+'') while
mutation is more effective against simpler problems (e.g. ``7xxx**+'').



\href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/graphs/gp-params.svg}{file:graphs/gp-params.svg}

\subsubsection*{Sub-populations and Sharing}
\label{sec-1.5.2}

After the basic GP operations had been verified we investigated the
effect of distributing the GP over multiple boards.  An series of runs
were performed using sharing frequencies of 100 milliseconds and
mutation and crossover frequencies of 10 milliseconds.  Times shown
are the average time taken to generate an ideal individual over 5
runs.  Although the effect of adding a second board was not dramatic
there is clear evidence that the addition of a second board and a
second population did increase the effectiveness of the GP.



\href{file:///nfs/adaptive/eschulte/src/gp4ixm-report/graphs/sharing.svg}{file:graphs/sharing.svg}

\subsubsection*{Sharing and Layout}
\label{sec-1.5.3}

Next the effects of different sharing rates run over a large group of
15 boards was investigated.  The sharing experiments were run over two
different board layouts -- a straight line and an altered figure
eight.  The results for each layout are presented as well as a
comparison between the two.  In all experiments below the following
three goals functions were used.  Each GP parameter combination was
allowed 10 minutes to attempt to fit each function.  10 runs were
performed in each setup and all reported results are the average of
the 10 runs.

\begin{itemize}

\item line\\
\label{sec-1.5.3.1}

The runtimes for each sharing rate by goal.  All sharing rates are
reported in milliseconds.  In general the results seem to illustrate
the a sharing rate of 1000 milliseconds performs best.
\begin{itemize}

\item "xxx**xxxx***+"\\
\label{sec-1.5.3.1.1}


\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &                3.8355099  \\
         1000  &                3.2090558  \\
          100  &                3.2239733  \\
\end{tabular}
\end{center}




\item "7xxx**+"\\
\label{sec-1.5.3.1.2}


\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &                4.9986461  \\
         1000  &                3.1983512  \\
          100  &                2.1230925  \\
\end{tabular}
\end{center}




\item "xs55+55+**"\\
\label{sec-1.5.3.1.3}

This goal is equivalent to $100 sine(x)$ which is not possible for our
GP individuals to match as they do not have the sine function as one
of their operators.  The average best score for each sharing rate is
reported.

\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &                  invalid  \\
         1000  &                  156.743  \\
          100  &                  164.008  \\
\end{tabular}
\end{center}



the reason that the above results for 10000 are labeled ``invalid'' is
that is appears that some boards did not successfully have their goal
reset from ``7xxx**+'' to ``xs55+55+**'' in these runs, so no data is
available.

\end{itemize} % ends low level

\item eight\\
\label{sec-1.5.3.2}

The runtimes for each sharing rate by goal.  All sharing rates are
reported in milliseconds.  In general the results seem to illustrate
the a sharing rate of 1000 milliseconds performs best.
\begin{itemize}

\item "xxx**xxxx***+"\\
\label{sec-1.5.3.2.1}


\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &                3.6102906  \\
         1000  &                2.8806907  \\
          100  &                6.4068757  \\
\end{tabular}
\end{center}




\item "7xxx**+"\\
\label{sec-1.5.3.2.2}


\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &               24.0118271  \\
         1000  &                3.1030883  \\
          100  &                1.9693912  \\
\end{tabular}
\end{center}




\item "xs55+55+**"\\
\label{sec-1.5.3.2.3}

This goal is equivalent to $100 sine(x)$ which is not possible for our
GP individuals to match as they do not have the sine function as one
of their operators.  The average best score for each sharing rate is
reported.

\begin{center}
\begin{tabular}{rr}
 sharing rate  &  ave. time to completion  \\
\hline
        10000  &         255.311111111111  \\
         1000  &         183.966666666667  \\
          100  &         253.433333333333  \\
\end{tabular}
\end{center}



\end{itemize} % ends low level

\item video results\\
\label{sec-1.5.3.3}

The following videos are provided to better illustrate the dynamic
fitness levels across multiple boards during the previous runs.  In
these videos each board is represented as a bar in a 3d histogram.
The placement of the bars mirrors the physical placement of the boards
and the height of the bar is equal to the most fit individual on the
board.  Recall that fitness is calculated as the \textbf{difference} between
an individual and the goal, so a lower fitness score is better.

\textbf{note}: if the following don't begin playing automatically they can be
saved to your desktop and played using a video player.  On a mac you
may need to use \href{http://www.videolan.org/vlc/}{VLC} if your default video player doesn't understand
these files.

\includemovie[
  poster,
  text={\small(Loading video)}
]{6cm}{6cm}{videos/evo_line_100_2_1.mp4}

\end{itemize} % ends low level
\subsubsection*{Coevolution}
\label{sec-1.5.4}


\subsection*{Future Work}
\label{sec-1.6}

\begin{itemize}
\item meta-GP
\item taking and giving boards
\item splitting up the fitness space across the boards
\end{itemize}

\subsection*{Reproduction and Expansion of this work}
\label{sec-1.7}
\label{reproduction}






[fn:4]

[fn:5]

[fn:6]   






\end{document}